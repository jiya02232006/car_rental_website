const authController = require('../../controllers/authController');\nconst db = require('../../config/database');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\n\n// Mock dependencies\njest.mock('../../config/database');\njest.mock('bcryptjs');\njest.mock('jsonwebtoken');\njest.mock('../../utils/authUtils');\njest.mock('../../utils/responseUtils');\n\ndescribe('Auth Controller', () => {\n  let req, res, next;\n\n  beforeEach(() => {\n    req = {\n      body: {},\n      user: {}\n    };\n    res = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn()\n    };\n    next = jest.fn();\n\n    // Clear all mocks\n    jest.clearAllMocks();\n  });\n\n  describe('register', () => {\n    const validUserData = {\n      email: 'test@example.com',\n      password: 'password123',\n      firstName: 'John',\n      lastName: 'Doe',\n      phone: '1234567890'\n    };\n\n    it('should register a new user successfully', async () => {\n      req.body = validUserData;\n      \n      // Mock database responses\n      db.query\n        .mockResolvedValueOnce([]) // User doesn't exist\n        .mockResolvedValueOnce({ insertId: 1 }); // User created\n      \n      bcrypt.hash.mockResolvedValue('hashedPassword');\n      jwt.sign.mockReturnValue('mockToken');\n\n      const { sendResponse } = require('../../utils/responseUtils');\n      sendResponse.mockImplementation((res, status, message, data) => {\n        res.status(status).json({ success: true, message, data });\n      });\n\n      await authController.register(req, res);\n\n      expect(db.query).toHaveBeenCalledWith(\n        'SELECT id FROM users WHERE email = ?',\n        [validUserData.email]\n      );\n      \n      expect(bcrypt.hash).toHaveBeenCalledWith(validUserData.password, 12);\n      \n      expect(db.query).toHaveBeenCalledWith(\n        'INSERT INTO users (email, password, first_name, last_name, phone) VALUES (?, ?, ?, ?, ?)',\n        ['test@example.com', 'hashedPassword', 'John', 'Doe', '1234567890']\n      );\n      \n      expect(sendResponse).toHaveBeenCalledWith(\n        res, \n        201, \n        'User registered successfully',\n        expect.objectContaining({\n          user: expect.objectContaining({\n            id: 1,\n            email: 'test@example.com',\n            firstName: 'John',\n            lastName: 'Doe',\n            phone: '1234567890',\n            role: 'customer'\n          }),\n          token: 'mockToken'\n        })\n      );\n    });\n\n    it('should return error if user already exists', async () => {\n      req.body = validUserData;\n      \n      // Mock user already exists\n      db.query.mockResolvedValueOnce([{ id: 1 }]);\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.register(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        409,\n        'User already exists with this email'\n      );\n    });\n\n    it('should return validation error for invalid data', async () => {\n      req.body = { email: 'invalid-email' };\n\n      // Mock validation error\n      const { registerValidation } = require('../../validators/authValidators');\n      registerValidation.mockReturnValue({\n        error: { details: [{ message: 'Email is invalid' }] }\n      });\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.register(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        400,\n        'Email is invalid'\n      );\n    });\n\n    it('should handle database errors', async () => {\n      req.body = validUserData;\n      \n      db.query.mockRejectedValueOnce(new Error('Database error'));\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.register(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        500,\n        'Internal server error'\n      );\n    });\n  });\n\n  describe('login', () => {\n    const validCredentials = {\n      email: 'test@example.com',\n      password: 'password123'\n    };\n\n    it('should login user successfully with valid credentials', async () => {\n      req.body = validCredentials;\n      \n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        password: 'hashedPassword',\n        first_name: 'John',\n        last_name: 'Doe',\n        phone: '1234567890',\n        role: 'customer'\n      };\n      \n      db.query.mockResolvedValueOnce([mockUser]);\n      bcrypt.compare.mockResolvedValueOnce(true);\n      jwt.sign.mockReturnValue('mockToken');\n\n      const { sendResponse } = require('../../utils/responseUtils');\n      sendResponse.mockImplementation((res, status, message, data) => {\n        res.status(status).json({ success: true, message, data });\n      });\n\n      await authController.login(req, res);\n\n      expect(db.query).toHaveBeenCalledWith(\n        'SELECT * FROM users WHERE email = ?',\n        [validCredentials.email]\n      );\n      \n      expect(bcrypt.compare).toHaveBeenCalledWith(\n        validCredentials.password,\n        mockUser.password\n      );\n      \n      expect(sendResponse).toHaveBeenCalledWith(\n        res,\n        200,\n        'Login successful',\n        expect.objectContaining({\n          user: expect.objectContaining({\n            id: 1,\n            email: 'test@example.com',\n            firstName: 'John',\n            lastName: 'Doe',\n            phone: '1234567890',\n            role: 'customer'\n          }),\n          token: 'mockToken'\n        })\n      );\n    });\n\n    it('should return error for non-existent user', async () => {\n      req.body = validCredentials;\n      \n      db.query.mockResolvedValueOnce([]);\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.login(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        401,\n        'Invalid credentials'\n      );\n    });\n\n    it('should return error for invalid password', async () => {\n      req.body = validCredentials;\n      \n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        password: 'hashedPassword',\n        first_name: 'John',\n        last_name: 'Doe'\n      };\n      \n      db.query.mockResolvedValueOnce([mockUser]);\n      bcrypt.compare.mockResolvedValueOnce(false);\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.login(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        401,\n        'Invalid credentials'\n      );\n    });\n  });\n\n  describe('getProfile', () => {\n    it('should return user profile successfully', async () => {\n      req.user = { id: 1 };\n      \n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        first_name: 'John',\n        last_name: 'Doe',\n        phone: '1234567890',\n        role: 'customer',\n        created_at: new Date()\n      };\n      \n      db.query.mockResolvedValueOnce([mockUser]);\n\n      const { sendResponse } = require('../../utils/responseUtils');\n      sendResponse.mockImplementation((res, status, message, data) => {\n        res.status(status).json({ success: true, message, data });\n      });\n\n      await authController.getProfile(req, res);\n\n      expect(db.query).toHaveBeenCalledWith(\n        'SELECT id, email, first_name, last_name, phone, role, created_at FROM users WHERE id = ?',\n        [1]\n      );\n      \n      expect(sendResponse).toHaveBeenCalledWith(\n        res,\n        200,\n        'Profile retrieved successfully',\n        expect.objectContaining({\n          user: expect.objectContaining({\n            id: 1,\n            email: 'test@example.com',\n            firstName: 'John',\n            lastName: 'Doe',\n            phone: '1234567890',\n            role: 'customer'\n          })\n        })\n      );\n    });\n\n    it('should return error if user not found', async () => {\n      req.user = { id: 999 };\n      \n      db.query.mockResolvedValueOnce([]);\n\n      const { sendError } = require('../../utils/responseUtils');\n      sendError.mockImplementation((res, status, message) => {\n        res.status(status).json({ success: false, message });\n      });\n\n      await authController.getProfile(req, res);\n\n      expect(sendError).toHaveBeenCalledWith(\n        res,\n        404,\n        'User not found'\n      );\n    });\n  });\n});